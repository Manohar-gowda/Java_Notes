package Basics;

/*
       Java is a high level, object-oriented, platform independent, programming language.
       If we develop a software using java then it can run on different platform.

       * Java run time environment: (JRE)
          Is a special software required to execute java programs and java application.

       * Compiler:
           Software used to check correctness of the program.
            javac is the name of the compiler.
          2 steps compilation:
             1. Check the syntax of the program.
             2. If the program is syntactically correct then byte code gets generated.

           If the program has syntactical mistakes then compiler throws compilation error.

       * Byte Code:
          It is an intermediate code generated by the compiler which neither high level or low level.
          only special software called JRE can understand the byte code.
          .class is the extension of byte code.

        * JRE can only understand byte code.
        * JDK is a type of SDK which internally has both the compiler as-well as JRE.

        * After successful compilation of the java program compiler generate default constructors the part of the
           byte code.
            class product {     // product.java  (developers code)
            }

            product() {      // Product.class   (default constructor)  (compiler generated code)
            }
        The default constructor is used to object creation.

    * Generalization:
       - The process of representing multiple different objects by a categories or type.
       Generalization via inheritance:
           In inheritance, a superclass(parent) represents the generalized form of its subclasses(children).

           Vehicle myCar = new Car(); // Upcasting to general type
           Vehicle myBike = new Bike();

     * Generics:
         - Java's generics provide another layer of generalization, allowing you to write classes, methods, or interfaces
            that work with any data type while maintaining safety.

            class Box<T> {
                private T item;

                public void setItem(T item) {
                    this.item = item;
                }

                public T getItem() {
                    return item;
                }
            }

            public class Main {
                public static void main(String[] args) {
                    Box<String> stringBox = new Box<>();  // General class, specific type
                    stringBox.setItem("Hello");
                    System.out.println(stringBox.getItem()); // Output: Hello

                    Box<Integer> intBox = new Box<>();
                    intBox.setItem(42);
                    System.out.println(intBox.getItem()); // Output: 42
                }
            }

      * public and default are access modifier:
         - if any java member is public then it can be accessed within the package and can also be
             accessed outside the package.
         - If any java member is default(non public) then it can't be accessed outside the package.

      * Associations:
         It is a relationship between two or more classes where objects of one class are related to objects of another class.
          - is-a relationship: (inheritance)
          - has-a relationship or uses-a:

          1. Aggregation:
              It is a weaker "has-a" relationship where the child can exist independently of the parent object.
               - the child object can outlive the parent object.

            class Engine {
                String type;

                Engine(String type) {
                    this.type = type;
                }

                void start() {
                    System.out.println(type + " engine started");
                }
            }

            class Car {
                Engine engine; // Aggregation: Car "has-an" Engine

                Car(Engine engine) {
                    this.engine = engine;
                }

                void drive() {
                    engine.start();
                    System.out.println("Car is driving");
                }
            }

            public class Main {
                public static void main(String[] args) {
                    Engine myEngine = new Engine("V8"); // Engine exists independently
                    Car myCar = new Car(myEngine);
                    myCar.drive(); // Output: V8 engine started, Car is driving

                    // Engine still exists even if Car is destroyed
                }
            }

       2. Composition:
           It is a stronger "has-a" relationship where the child object's lifecycle is tied to the parent object.
            If parent is destroyed, the child is too.
            The child object is created and managed by the parent.

            class Wheel {
                String position;

                Wheel(String position) {
                    this.position = position;
                }

                void rotate() {
                    System.out.println(position + " wheel is rotating");
                }
            }

            class Car {
                Wheel frontLeft; // Composition: Car "owns" its Wheels
                Wheel frontRight;

                Car() {
                    // Wheels are created within Car
                    frontLeft = new Wheel("Front Left");
                    frontRight = new Wheel("Front Right");
                }

                void drive() {
                    frontLeft.rotate();
                    frontRight.rotate();
                    System.out.println("Car is moving");
                }
            }

            public class Main {
                public static void main(String[] args) {
                    Car myCar = new Car();
                    myCar.drive();
                    // Output: Front Left wheel is rotating, Front Right wheel is rotating, Car is moving

                    // If myCar is destroyed, its wheels are too
                }
            }

      * Data member:
         It is a container or data holder which is used to store data.

         1. Variable:
            Data can be changed.
            Programmatically a non-final member is considered as variable.

            datatype variableName = data;

            a. Local variable:
               - Any variable which is declared in local scope.
               - variable declared in method or block or constructor is called local variable.
               - Local variable must initialize before it is used.

               class Test {
                 {
                   boolean b;
                   sout(b);  // compilation error || reason: Local variable is not initialized.
                 }
               }

               - Local variables cannot be accessed outside the scope it is accessed only inside the block or local scope
               - Two variables present in the different scope can have the same name.

            b. Global variable:
                - Any variable which is directly declared inside the global scope or outside the local scope.
                - If the global variable is public it can be accessed from the other packages.
                - If we don't initialize global variable then it automatically initialize default value of that datatype.

         * Instance variable:
            - It is declared directly inside class outside method, constructor or bock.
            - Represents the state of an object.
            - Created in the memory only when object is gets created.
            - Can be accessed within the same class either directly using variable name or using "this" keyword.
            - We can initialize instance variable even using methods.

         2. Constants:
            Data can't be changed.
            Programmatically constant is declared using keyword final.
            final datatype constantName  = data;

            - Final: is a keyword used with variable, method and class.
              - final variable: cannot reinitialize(constant).
              - final method: cannot override final method, but we can inherit it.
              - final class: we cannot inherit final

      * Constructor:
         - Used to initialize instance variable or resource.
         - Constructor must be same as class name
         - Can't have any return type.

          1. Default / implicit:
          2. Custom:
             - Used to initialize instance variable to custom values.
             - A class can have either default or custom constructor but not both.
             - Access modifier of custom constructor didn't same as the class it can have its own access modifier.

      -- Between constructor and instance block, the instance block is given the highest preference hence it is
           executed first before the constructor.

       * Variable shadowing:
           A global variable and local variable can have same name in their case, inside the local scope the local
              variable dominates the global variable which is called as this.

       * Methods:
          - Represents a behaviour of object.
          - The methods can be static or non-static.
            1. Concrete:
               Complete method which has both method declaration and implementation.
               String getName() {
                   return "Manohar";
               }

            2. Abstract method:
               Only have method declaration.
               abstract void Click();
               - We cannot invoke abstract method.

      * A method can have same name as class, but not a good practice.
      * We can invoke main method but not a good practice because it is automatically executed by JVM.

      * Method calling rules:
         1. A method can invoke the other method of the same class just by the name, object reference is not required.
         2. Any static member can't directly invoke a non-static member, rather object reference is required.
         3. A method of class can invoke the other method of other class by using object reference or object.

      * Void: indicates that a method does not return any data.

      * return: statement used inside a method to return the data.
         - Methods can have only one return type.

      * This: keyword which refers to the present and current invoking object.
       - We can't use 'this' keyword for static methods and blocks because they belong to class.

      * Signature:
         Characteristics which are used to describe the parameters.

         1. Number of Parameters.
         2. Data type of parameter.
         3. Order of sequence of parameters.

      * Method overloading:
          - Having multiple methods in a class with same name but change in the signature is called method overloading.
          - Method overloading is a way to achieve compile time polymorphism or early binding.
          - don't consider method return type.
          - static methods are overloaded.
          - main method can be overloaded but useless.

      * diff b/w constructor and method:
          Constructor:
            - name must be same as class name.
            - can't have return type.
            - cannot be inherited.
            - cannot be static.
            - cannot be abstract.
            - cannot be final.

          Method:
            - can have any name.
            - must have return type.
            - can be inherited.
            - can be static.
            - can be abstract.
            - can be final.

  * Static:
    - All static member will get stored inside a memory location called as class area / static pool.
    - All static member will have only one copy per class.
    - All static member should be accessed using class name.
    - In java any component which belongs to class level is represented as static.
    - static component of a class are allotted memory on to the method area.
    - static variables are declared inside the class but outside the methods.
    - Not only that static variables are also allotted default values if the programmer does not provide any value.

    - We should declare variable as static when the same value can be shared by all the objects.
    - We should declare a variable as non-static i.e., instance when the value for it will be different for different objects.

    Static methods:
    - are also class level component and can directly be access using the class name.
    - We use static methods when we need to communicate a message that applies universally across all instance of a class.

    Static Blocks:
    - These are executed(class loader) before the  main class started to execute, these are used to initialize static variables.

    * Access modifiers:
                Highest visibility           1. public:               Lowest security
                       |                     2. protected.                   |
                       |                     3. default.                     |
                the lowest visibility        4. private.               highest security

       - We can access the protected member in different package using IS-A relationship and import statement but
           super class should be public.

     * Blocks:
         It is a piece of code or set of instructions which are written inside the curly braces.
         A java block can't have the name hence automatically executed by JVM.

         Types:
           1. non-static bock / instance block:
             Also called as object block, which is automatically executed by jvm when object gets created.
             The number of times the instance block executed depends on the number of objects.


 */

public class Basics {
    public static void main(String[] args) {
        Box<String> b1 = new Box<String>();
        b1.setItem("manohar");
        System.out.println(b1.getItem());
    }
}

class Box<T> {
    private T item;

    public void setItem(T item) {
        this.item = item;
    }

    public T getItem() {
        return item;
    }
}



